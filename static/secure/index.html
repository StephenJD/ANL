<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Auth0 Debug Full (+ token request interception)</title>
  <script id="auth0script" src="https://cdn.auth0.com/js/auth0-spa-js/2.1.2/auth0-spa-js.production.js"></script>
  <style>
    body { font-family: system-ui, Arial; padding: 1rem; }
    #status { margin-bottom: .5rem; font-weight: bold; }
    #debug { white-space: pre-wrap; background:#111; color:#bfb; padding:12px; max-height:55vh; overflow:auto; }
    button { margin-right: .5rem; }
  </style>
</head>
<body>
  <div id="status">Status: ...</div>
  <button id="loginBtn">Login</button>
  <button id="logoutBtn">Logout</button>
  <pre id="debug"></pre>

<script>
/*
  Full debugging page with fetch & XHR interception for /oauth/token calls.
  - Keeps your confirmed baseline config.
  - Intercepts network calls to OAuth token endpoint and logs request and response details,
    redacting token strings but showing keys/status.
  - Shows lots of environment info to help diagnose where the flow fails.
*/

const pre = document.getElementById('debug');
const statusDiv = document.getElementById('status');

// === CONFIG ===
const showBothButtons = true; // keep true while debugging
const AUTH0_DOMAIN = "dev-5lsalv0spwawvbl7.uk.auth0.com";
const CLIENT_ID = "8FJRW4DzlhHnnUGSbRkF8StwIxQ4zBzf";
const AUDIENCE = "https://ascendnextlevel.org.uk";
const REDIRECT_PATH = "/secure/"; // ensure auth0 app callback and logout use this exact path

const authConfig = {
  domain: AUTH0_DOMAIN,
  client_id: CLIENT_ID,
  useFormData: true,
  cacheLocation: "localstorage",
  useRefreshTokens: true,
  authorizationParams: {
    redirect_uri: window.location.origin + REDIRECT_PATH,
    audience: AUDIENCE,
    scope: "openid profile email",
    client_id: CLIENT_ID
  }
};

// === Helpers ===
function append(msg, obj) {
  const line = msg + (obj ? ': ' + (typeof obj === 'string' ? obj : JSON.stringify(obj, null, 2)) : '');
  pre.textContent += line + '\n';
  console.log(msg, obj || '');
}
function redactTokens(obj) {
  if (!obj || typeof obj !== 'object') return obj;
  const copy = Array.isArray(obj) ? [...obj] : {...obj};
  const redactField = v => (typeof v === 'string' && v.length > 12) ? `${v.slice(0,8)}…(len=${v.length})` : v;
  for (const k of Object.keys(copy)) {
    if (/token|id_token|access_token|refresh_token|client_secret/i.test(k)) {
      copy[k] = redactField(copy[k]);
    } else if (typeof copy[k] === 'string' && copy[k].startsWith('eyJ')) { // possible JWT
      copy[k] = redactField(copy[k]);
    }
  }
  return copy;
}
function dumpEnvironment(label) {
  const ls_keys = Object.keys(localStorage);
  const ss_keys = Object.keys(sessionStorage);
  const ss_items = {};
  ss_keys.forEach(k => ss_items[k] = sessionStorage.getItem(k));
  append(`${label} - Environment dump`, {
    localStorage_keys: ls_keys,
    sessionStorage_keys: ss_keys,
    sessionStorage_items: ss_items,
    cookies: document.cookie || "(none)"
  });
}
function logFailureContext(client, extra) {
  const scriptTag = document.getElementById('auth0script');
  const scriptSrc = scriptTag ? scriptTag.src : "(no src)";
  const versionMatch = scriptSrc.match(/auth0-spa-js\/([^/]+)/);
  const sdkVersion = versionMatch ? versionMatch[1] : "(unknown)";
  const clientConfig = client ? client.options : authConfig;
  append("FATAL: Auth0 SPA SDK failure context", {
    script: scriptSrc,
    version: sdkVersion,
    clientConfig,
    error: extra || {}
  });
}

// === Network interception for /oauth/token ===
(function installNetworkInterceptors() {
  // fetch interceptor
  const origFetch = window.fetch;
  window.fetch = async function(input, init) {
    try {
      const url = (typeof input === 'string') ? input : (input && input.url) || '';
      const isToken = url && url.includes('/oauth/token') && url.includes(AUTH0_DOMAIN);
      if (isToken) {
        // log request details (redact sensitive values)
        let reqBody = init && init.body;
        let parsed = null;
        if (typeof reqBody === 'string') {
          try { parsed = JSON.parse(reqBody); } catch(e){ parsed = {raw: reqBody}; }
        } else if (reqBody instanceof FormData) {
          const obj = {};
          for (const [k,v] of reqBody.entries()) obj[k]=v;
          parsed = obj;
        } else parsed = reqBody;
        append("[NETWORK] fetch -> oauth/token request", { url, method: init && init.method, body_keys: parsed ? Object.keys(parsed) : undefined, body_sample: redactTokens(parsed) });
      }
      const resp = await origFetch.apply(this, arguments);
      if (isToken) {
        // clone and attempt to get JSON/text; do not dump full token values
        let clone = resp.clone();
        let bodyText;
        try {
          const json = await clone.json();
          bodyText = redactTokens(json);
        } catch (e) {
          try { bodyText = await clone.text(); } catch(e2) { bodyText = '(no body)'; }
        }
        append("[NETWORK] fetch <- oauth/token response", { url, status: resp.status, body: bodyText });
      }
      return resp;
    } catch (err) {
      append("[NETWORK] fetch ERROR", err && (err.message || err));
      throw err;
    }
  };

  // XMLHttpRequest interceptor
  const origOpen = XMLHttpRequest.prototype.open;
  const origSend = XMLHttpRequest.prototype.send;
  XMLHttpRequest.prototype.open = function(method, url) {
    this.__method = method;
    this.__url = url;
    return origOpen.apply(this, arguments);
  };
  XMLHttpRequest.prototype.send = function(body) {
    const url = this.__url || '';
    const isToken = url.includes('/oauth/token') && url.includes(AUTH0_DOMAIN);
    if (isToken) {
      let parsed = null;
      if (typeof body === 'string') {
        try { parsed = JSON.parse(body); } catch(e){ parsed = body; }
      }
      append("[NETWORK] XHR -> oauth/token request", { url, method: this.__method, body_keys: parsed && typeof parsed === 'object' ? Object.keys(parsed) : undefined, body_sample: redactTokens(parsed) });
      this.addEventListener('load', function() {
        let respText = this.responseText;
        let safe = '(unparsable)';
        try {
          const j = JSON.parse(respText);
          safe = redactTokens(j);
        } catch(e) {
          safe = respText ? respText.slice(0,1000) + (respText.length>1000? "…(truncated)":"") : "(empty)";
        }
        append("[NETWORK] XHR <- oauth/token response", { url, status: this.status, body: safe });
      });
      this.addEventListener('error', function() {
        append("[NETWORK] XHR ERROR for oauth/token", { url });
      });
    }
    return origSend.apply(this, arguments);
  };
})();

// === Core Auth0 flow (based on your working baseline) ===
window.onload = async () => {
  append("=== Auth0 init start ===");
  dumpEnvironment("Before Auth0 client creation");

  if (!window.auth0) {
    logFailureContext(null, { message: "Auth0 global not found" });
    append("FATAL: Auth0 global not found - check auth0-spa-js script path and network.");
    return;
  }

  let client;
  try {
    append("Creating Auth0 client (authConfig shown)", authConfig);
    client = await auth0.createAuth0Client(authConfig);
    append("Auth0 client created: client.options", client.options);
  } catch (err) {
    logFailureContext(null, err);
    append("FATAL ERROR creating client", err && (err.message || err));
    return;
  }

  // If page returned from auth0: handle redirect callback
  if (window.location.search.includes('code=') && window.location.search.includes('state=')) {
    append("Login redirect detected", { query: window.location.search });
    dumpEnvironment("Before handleRedirectCallback");
    try {
      const result = await client.handleRedirectCallback();
      append("handleRedirectCallback result", redactTokens(result));
      dumpEnvironment("After handleRedirectCallback");
      // ensure the URL matches the expected redirect path (strip query)
      try {
        window.history.replaceState({}, document.title, REDIRECT_PATH);
      } catch(e) {
        // fallback
        window.location.replace(REDIRECT_PATH);
        return;
      }
    } catch (err) {
      // Auth0 SDK sometimes throws empty objects; handle gracefully
      if (!err || (Object.keys(err).length === 0)) {
        append("handleRedirectCallback returned empty error, ignoring:", err);
      } else {
        logFailureContext(client, err);
        append("Error handling redirect callback (detailed)", redactTokens(err));
      }
    }
  }

  // Check authentication state
  let isAuth = false;
  try {
    append("Calling client.isAuthenticated()");
    isAuth = await client.isAuthenticated();
    append("isAuthenticated() =>", isAuth);
  } catch (err) {
    logFailureContext(client, err);
    append("Error checking authentication", err && (err.message || err));
  }

  // If authenticated, try to fetch user info + token claims (redacted)
  if (isAuth) {
    try {
      const claims = await client.getIdTokenClaims();
      append("getIdTokenClaims()", redactTokens(claims || {}));
    } catch (e) {
      append("getIdTokenClaims() error", e && (e.message || e));
    }
    try {
      const user = await client.getUser();
      append("getUser()", redactTokens(user || {}));
    } catch (e) {
      append("getUser() error", e && (e.message || e));
    }
  }

  // Update UI
  statusDiv.textContent = "Status: " + (isAuth ? "Logged in" : "Logged out");
  if (!showBothButtons) {
    document.getElementById('loginBtn').style.display = isAuth ? "none" : "inline-block";
    document.getElementById('logoutBtn').style.display = isAuth ? "inline-block" : "none";
  } else {
    // ensure both are visible for debugging
    document.getElementById('loginBtn').style.display = "inline-block";
    document.getElementById('logoutBtn').style.display = "inline-block";
  }

  // Wire buttons
  document.getElementById('loginBtn').onclick = async () => {
    append("Login button clicked");
    try {
      await client.loginWithRedirect();
    } catch (err) {
      logFailureContext(client, err);
      append("loginWithRedirect error", err && (err.message || err));
    }
  };

  document.getElementById('logoutBtn').onclick = () => {
    append("Logout button clicked");
    const returnTo = window.location.origin + REDIRECT_PATH;
    const logoutUrl = `https://${client.options.domain}/v2/logout?returnTo=${encodeURIComponent(returnTo)}&client_id=${client.options.client_id}`;
    append("Redirecting to logout URL", logoutUrl);
    // immediate redirect to clear server session
    window.location.href = logoutUrl;
  };

  dumpEnvironment("Final environment dump");
  append("Auth0 init complete — UI ready");
};
</script>
</body>
</html>
