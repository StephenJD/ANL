<!-- layouts/partials/form_verified.html -->
<div class="form-request-box">
  <p>Enter your email to enable the form:</p>
  <input type="email" class="request-email" placeholder="Your email" required>
  <button type="button" class="request-token-btn">Request Link</button>
  <div class="token-message" style="color:red;margin-top:0.5em;"></div>
</div>

<script>
document.addEventListener('DOMContentLoaded', async () => {
  const form = document.querySelector('form.verified-form');
  const requestBox = document.querySelector('.form-request-box');
  if (!form || !requestBox) return;

  const messageBox = requestBox.querySelector('.token-message');
  const btn = requestBox.querySelector('.request-token-btn');
  const emailInput = requestBox.querySelector('.request-email');

  // --- Read validation mode ---
  const validationMode = window.PAGE_FRONTMATTER?.params?.validation || "none";
  const requireRequestLink = validationMode.includes("requestLink");
  const requireFinalSubmit = validationMode.includes("submit");

  // Disable inputs initially if requestLink is required
  form.querySelectorAll('input, textarea, select, button[type="submit"]').forEach(el => {
    el.disabled = requireRequestLink;
  });

  // Hide request box if not needed
  if (!requireRequestLink) {
    requestBox.style.display = 'none';
  }

  // Autofill date fields
  document.querySelectorAll('input[type="date"].autofill-today').forEach(input => {
    input.valueAsDate = new Date();
  });

  // --- NEW: submitted_by input logic ---
  let submittedByInput = form.querySelector('#submitted_by');
  if (!submittedByInput) {
    const wrapper = document.createElement('div');
    wrapper.style.marginTop = '1em';

    const label = document.createElement('label');
    label.setAttribute('for', 'submitted_by');
    label.textContent = "Optional email to receive a copy of your submission:";

    submittedByInput = document.createElement('input');
    submittedByInput.type = 'email';
    submittedByInput.id = 'submitted_by';
    submittedByInput.name = 'submitted_by';
    submittedByInput.placeholder = 'you@example.com';

    wrapper.appendChild(label);
    wrapper.appendChild(submittedByInput);
    form.appendChild(wrapper);
  }

  // Validate optional email on submit
  form.addEventListener('submit', (e) => {
    const emailVal = submittedByInput.value.trim();
    if (emailVal && !/\S+@\S+\.\S+/.test(emailVal)) {
      e.preventDefault();
      alert("Please enter a valid email address or leave the field empty.");
    }
  });

  // Request link button behavior
  if (requireRequestLink) {
    btn.addEventListener('click', async () => {
      const email = emailInput.value.trim();
      if (!email) { alert("Enter your email first"); return; }

      try {
        const resp = await fetch("/.netlify/functions/sendFormAccessLink", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            email,
            formPath: window.location.pathname,
            formName: form.name || document.title,
            site_root: window.location.origin
          })
        });
        const data = await resp.json();
        alert(data.success ? "Check your email for the link." : "Error sending link: " + (data.error || "unknown error"));
      } catch (err) {
        console.error(err);
        alert("Request failed");
      }
    });
  }

  // Token verification (initial enable / final submit)
  const params = new URLSearchParams(window.location.search);
  const token = params.get('token');
  const email = params.get('email');
  const formPath = window.location.pathname;
  const isFinal = params.get('final') === '1' || params.get('final') === 'true';

  if (token && email) {
    // --- requestLink flow ---
    if (!isFinal && requireRequestLink) {
      try {
        const resp = await fetch("/.netlify/functions/verifyToken_ClientWrapper", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ token, email, formPath })
        });
        const data = await resp.json();
        if (data.valid) {
          form.querySelectorAll('input, textarea, select, button[type="submit"]').forEach(el => el.disabled = false);
          requestBox.style.display = 'none';
          messageBox.style.display = 'none';
          console.log("Token valid, form enabled.");
        } else {
          messageBox.textContent = "Invalid link. It may have expired, or is for the wrong email/form.";
        }
      } catch (err) {
        console.error("Error verifying token:", err);
      }
    }

    // --- submit flow ---
    if (isFinal && requireFinalSubmit) {
      try {
        const resp = await fetch('/.netlify/functions/verifyFinalToken', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ token })
        });
        const data = await resp.json();
        if (data.valid) {
          console.log("Final token valid â€” proceed with submission.");
        } else {
          messageBox.textContent = "Final link expired or invalid.";
        }
      } catch (err) {
        console.error("Error verifying final token:", err);
      }
    }
  }

  // Inline-fit layout
  function updateInlineFit() {
    const form = document.querySelector("form.verified-form");
    if (!form) return;
    const formWidth = form.offsetWidth;
    const allInputs = form.querySelectorAll("input, select");
    allInputs.forEach(inputElem => {
      const label = inputElem.previousElementSibling;
      if (!label || label.tagName !== "LABEL") return;
      const inputWidth = inputElem.getBoundingClientRect().width;
      if (inputWidth + 16 < formWidth) {
        label.classList.add("inline-fit");
        inputElem.classList.add("inline-fit");
      } else {
        label.classList.remove("inline-fit");
        inputElem.classList.remove("inline-fit");
      }
    });
  }
  requestAnimationFrame(updateInlineFit);
  window.addEventListener("load", updateInlineFit);
  window.addEventListener("resize", updateInlineFit);
});
</script>
