{{/* layouts/forms/single.html */}}
{{ define "main" }}
  <link rel="stylesheet" href="{{ "css/forms.css" | relURL }}">

  <div class="form-container">
    <h1>{{ .Title }}</h1>
    {{ partial "qr_code.html" . }}
    {{ partial "form_request.html" . }}
  
    <form name="{{ .Title | urlize }}" autocomplete="off" class="verified-form" data-netlify="true" netlify>
      {{ .Content }}
      {{ partial "form_submit_button.html" . }}
    </form>
    
    <script>
      function inlineFitInputs(form) {
        if (!form) return;
        const formWidth = form.offsetWidth;
        form.querySelectorAll("input, select").forEach(elem => {
          const label = elem.previousElementSibling;
          if (!label || label.tagName !== "LABEL") return;
          const elemWidth = elem.getBoundingClientRect().width;
          if (elemWidth + 16 < formWidth) {
            label.classList.add("inline-fit");
            elem.classList.add("inline-fit");
          } else {
            label.classList.remove("inline-fit");
            elem.classList.remove("inline-fit");
          }
        });
      }

      function inlineFitButtonRows(form) {
        if (!form) return;
        const buttons = Array.from(form.querySelectorAll("button"));
        for (let i = 0; i < buttons.length - 1; i++) {
          const current = buttons[i];
          const next = buttons[i + 1];
          if (current.offsetTop === next.offsetTop) {
            current.classList.add("inline-fit");
            next.classList.add("inline-fit");
          } else {
            current.classList.remove("inline-fit");
            next.classList.remove("inline-fit");
          }
        }
      }

      function renameRadioGroups(form) {
        if (!form) return;
        let counter = 0;
        form.querySelectorAll('fieldset').forEach(fs => {
          const radios = fs.querySelectorAll('input[type="radio"]');
          if (!radios.length) return;
          counter++;
          radios.forEach(r => r.name = `r${counter}`);
        });
      }

      function disableAutocompleteDates(form) {
        if (!form) return;
        form.querySelectorAll('input[type="date"]').forEach(input => input.setAttribute('autocomplete', 'off'));
      }

      function autofillTodayDates(form) {
        if (!form) return;
        form.querySelectorAll('input[type="date"].autofill-today').forEach(input => { input.valueAsDate = new Date(); });
      }

      function markAllRequiredFieldsets() {
        document.querySelectorAll("fieldset").forEach(fs => {
          const inputs = fs.querySelectorAll("input, textarea, select");
          const allRequired = Array.from(inputs).every(input => input.hasAttribute("required"));
          if (allRequired) fs.classList.add("all-required");
        });
      }

      function enableOptionalEmail() {
        const form = document.querySelector("form.verified-form");
        if (!form) return;
        const optionalEmail = form.querySelector("#optionalEmail");
        const hasSubmittedBy = form.querySelector("#submitted_by") !== null;
        if (!hasSubmittedBy && optionalEmail) optionalEmail.style.display = "block";
      }

      function updateInlineFit() {
        const form = document.querySelector("form.verified-form");
        inlineFitInputs(form);
        inlineFitButtonRows(form);
        renameRadioGroups(form);
        disableAutocompleteDates(form);
        autofillTodayDates(form);
      }

      document.addEventListener("DOMContentLoaded", () => {
        enableOptionalEmail();
        updateInlineFit();
        markAllRequiredFieldsets();
      });

      window.addEventListener("resize", updateInlineFit);
    </script>
    
    <script src="{{ "js/form_access_controller.js" | relURL }}" defer></script>
  </div>
{{ end }}
