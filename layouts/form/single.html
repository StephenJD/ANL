{{/* layouts/forms/single.html */}}
{{ define "main" }}
  {{ $current_page := . }}
  {{ $breadcrumb_page_types := site.Params.breadcrumb.page_types | default dict }}
  {{ $show_breadcrumb := index $breadcrumb_page_types .Type | default false }}

  <link rel="stylesheet" href="{{ "css/forms.css" | relURL }}">

  <div class="form-container">
    <div class="no-print">
      {{ if $show_breadcrumb }}
        {{ partial "breadcrumb" $current_page }}
      {{ end }}
    </div>    
    <h1>{{ .Title }}</h1>
    {{ partial "qr_code.html" . }}
    {{ partial "form_request.html" . }}

    <form name="{{ .Title | urlize }}" autocomplete="off" class="verified-form" data-netlify="true" netlify>
      <!-- Placeholder (only real DOM for restricted pages) -->
      <div id="gated-form-placeholder">Loading formâ€¦</div>
        {{ partial "form_submit_button.html" . }}
    </form>
  </div>

<script type="module" src="{{ "js/form_access_controller.js" | relURL }}" defer></script>

<script type="module">
import { restrictUsers } from "/js/form_access_controller.js";

/* ------------- Initialization (orchestration) ------------- */
document.addEventListener("DOMContentLoaded", async () => {
  await waitForSetupAccessControls();
  console.log("[DEBUG] setupAccessControls available");

  const path = window.location.pathname;
  const formContainer = document.getElementById("gated-form-placeholder");
  const formName = "{{ .File.BaseFileName | urlize }}";
  const form = document.querySelector("form.verified-form");

  if (!form) {
    console.warn("[DEBUG] No form found, aborting initialization");
    return;
  }

  console.log("[DEBUG] submitBox in DOM before setupAccessControls:", document.querySelector(".form-submit-box"));

  runFormHelpers(form);

  // signal downstream scripts that form access & helpers are ready
  document.dispatchEvent(new CustomEvent("formAccessReady", { detail: { formName, restrictUsers } }));

  console.log("[DEBUG] Form initialization complete");
});

async function waitForSetupAccessControls() {
  return new Promise(resolve => {
    const check = () => {
      if (typeof window.setupAccessControls === "function") resolve();
      else requestAnimationFrame(check);
    };
    check();
  });
}

function runFormHelpers(form) {
  enableOptionalEmail(form);
  updateInlineFit(form);
  markAllRequiredFieldsets(form);
  renameRadioGroups(form);
  disableDateAutocomplete(form);
  autofillToday(form);
  disableRadiosUntilChecked(form);

  // expose helpers that user code expects on window
  window.autofillToday = () => autofillToday(form);
  window.disableRadiosUntilChecked = () => disableRadiosUntilChecked(form);
  window.addEventListener("resize", () => updateInlineFit(form));

  // finally, call setupAccessControls using the form reference
  if (typeof window.setupAccessControls === "function") {
    window.setupAccessControls(form);
  } else {
    console.warn("[DEBUG] setupAccessControls not available when runFormHelpers called");
  }
}

/*
// Execute all scripts inside a container once (accepts Element or DocumentFragment)
function executeInjectedScripts(container) {
  if (!container) return;
  const nodeType = container.nodeType;
  if (nodeType !== 1 && nodeType !== 11) return; // Element(1) or DocumentFragment(11)

  const executedAttr = "data-scripts-executed";
  if (container.nodeType === 1 && container.hasAttribute(executedAttr)) return;
  if (container.nodeType === 1) container.setAttribute(executedAttr, "true");

  // querySelectorAll works on Element and DocumentFragment
  container.querySelectorAll("script").forEach(oldScript => {
    const newScript = document.createElement("script");
    newScript.type = oldScript.type || "text/javascript";
    if (oldScript.src) {
      newScript.src = oldScript.src;
      newScript.async = false; // preserve execution order
    } else {
      newScript.textContent = oldScript.textContent;
    }
    oldScript.replaceWith(newScript);
  });

  console.log("[DEBUG] Injected scripts executed for container:", container);
}
*/
/* ------------- Form helper functions - each accepts `form` explicitly ------------- */

function updateInlineFit(form) {
  const marginBuffer = 8;
  const fitElements = (elements) => {
    const visible = elements.filter(el => el.offsetParent !== null);
    const totalWidth = visible.reduce((sum, el) => sum + el.getBoundingClientRect().width + marginBuffer, 0);
    visible.forEach(el => el.classList.toggle("inline-fit", totalWidth < form.offsetWidth));
  };

  form.querySelectorAll("input, select").forEach(input => {
    const label = input.previousElementSibling;
    if (label && label.tagName === "LABEL") fitElements([label, input]);
  });

  const buttons = Array.from(form.querySelectorAll("button"));
  for (let i = 0; i < buttons.length; i++) {
    const row = [buttons[i]];
    let next = buttons[i].nextElementSibling;
    while (next && next.tagName === "BUTTON") {
      row.push(next);
      i++;
      next = next.nextElementSibling;
    }
    if (row.length > 1) fitElements(row);
  }
}

function markAllRequiredFieldsets(form) {
  form.querySelectorAll("fieldset").forEach(fs => {
    const inputs = fs.querySelectorAll("input, textarea, select");
    if (Array.from(inputs).every(input => input.hasAttribute("required"))) fs.classList.add("all-required");
  });
}

function enableOptionalEmail(form) {
  const optionalEmail = form.querySelector("#optionalEmail");
  const hasSubmittedBy = form.querySelector("#submitted_by") !== null;
  if (!hasSubmittedBy && optionalEmail) optionalEmail.style.display = "block";
}

function renameRadioGroups(form) {
  let groupCounter = 0;
  let currentGroupRadios = [];
  const elements = Array.from(form.querySelectorAll('label, legend'));
  elements.forEach(el => {
    const radios = el.querySelectorAll('input[type="radio"]');
    if (radios.length) currentGroupRadios.push(...radios);
    else if (currentGroupRadios.length) {
      groupCounter++;
      currentGroupRadios.forEach(r => r.name = `r${groupCounter}`);
      currentGroupRadios = [];
    }
  });
  if (currentGroupRadios.length) {
    groupCounter++;
    currentGroupRadios.forEach(r => r.name = `r${groupCounter}`);
  }
}

function disableDateAutocomplete(form) {
  form.querySelectorAll('input[type="date"]').forEach(input => input.setAttribute('autocomplete', 'off'));
}

function autofillToday(form) {
  form.querySelectorAll('input[type="date"].autofill-today').forEach(input => { input.valueAsDate = new Date(); });
}

function disableRadiosUntilChecked(form) {
  form.querySelectorAll('input[type="checkbox"]').forEach(cb => {
    const radioFieldset = cb.closest('fieldset')?.querySelector('fieldset');
    if (!radioFieldset) return;
    const updateRadios = () => radioFieldset.disabled = !cb.checked;
    updateRadios();
    cb.addEventListener('change', updateRadios);
  });
}
</script>
{{ end }}
